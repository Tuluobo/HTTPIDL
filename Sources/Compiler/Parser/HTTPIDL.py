# Generated from /Users/xudong/git/HTTPIDL/Grammar/HTTPIDL.g4 by ANTLR 4.6
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"%\u0094\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\3\2\3\2\7\2-\n\2\f\2\16")
        buf.write(u"\2\60\13\2\3\2\5\2\63\n\2\3\3\3\3\3\3\3\3\3\3\7\3:\n")
        buf.write(u"\3\f\3\16\3=\13\3\3\3\3\3\3\4\3\4\3\4\3\4\3\5\3\5\3\5")
        buf.write(u"\3\5\3\6\3\6\3\6\3\6\3\7\3\7\3\b\3\b\7\bQ\n\b\f\b\16")
        buf.write(u"\bT\13\b\3\t\3\t\5\tX\n\t\3\n\3\n\7\n\\\n\n\f\n\16\n")
        buf.write(u"_\13\n\3\n\3\n\3\13\3\13\3\13\3\f\3\f\3\f\3\f\5\fj\n")
        buf.write(u"\f\3\f\3\f\3\r\3\r\5\rp\n\r\3\16\3\16\3\16\3\16\5\16")
        buf.write(u"v\n\16\3\17\3\17\3\17\3\17\3\20\3\20\3\20\3\20\3\20\3")
        buf.write(u"\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u008a")
        buf.write(u"\n\21\3\22\3\22\3\23\3\23\3\24\3\24\3\25\3\25\3\25\2")
        buf.write(u"\2\26\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(\2")
        buf.write(u"\3\3\2\5\r\u0091\2\62\3\2\2\2\4\64\3\2\2\2\6@\3\2\2\2")
        buf.write(u"\bD\3\2\2\2\nH\3\2\2\2\fL\3\2\2\2\16R\3\2\2\2\20W\3\2")
        buf.write(u"\2\2\22Y\3\2\2\2\24b\3\2\2\2\26e\3\2\2\2\30o\3\2\2\2")
        buf.write(u"\32u\3\2\2\2\34w\3\2\2\2\36{\3\2\2\2 \u0089\3\2\2\2\"")
        buf.write(u"\u008b\3\2\2\2$\u008d\3\2\2\2&\u008f\3\2\2\2(\u0091\3")
        buf.write(u"\2\2\2*-\5\4\3\2+-\5\6\4\2,*\3\2\2\2,+\3\2\2\2-\60\3")
        buf.write(u"\2\2\2.,\3\2\2\2./\3\2\2\2/\63\3\2\2\2\60.\3\2\2\2\61")
        buf.write(u"\63\7\2\2\3\62.\3\2\2\2\62\61\3\2\2\2\63\3\3\2\2\2\64")
        buf.write(u"\65\7\3\2\2\65\66\5\16\b\2\66;\7\21\2\2\67:\5\b\5\28")
        buf.write(u":\5\n\6\29\67\3\2\2\298\3\2\2\2:=\3\2\2\2;9\3\2\2\2;")
        buf.write(u"<\3\2\2\2<>\3\2\2\2=;\3\2\2\2>?\7\22\2\2?\5\3\2\2\2@")
        buf.write(u"A\7\4\2\2AB\5&\24\2BC\5\22\n\2C\7\3\2\2\2DE\5\f\7\2E")
        buf.write(u"F\7\16\2\2FG\5\22\n\2G\t\3\2\2\2HI\5\f\7\2IJ\7\17\2\2")
        buf.write(u"JK\5\22\n\2K\13\3\2\2\2LM\t\2\2\2M\r\3\2\2\2NO\7\20\2")
        buf.write(u"\2OQ\5\20\t\2PN\3\2\2\2QT\3\2\2\2RP\3\2\2\2RS\3\2\2\2")
        buf.write(u"S\17\3\2\2\2TR\3\2\2\2UX\5(\25\2VX\5\24\13\2WU\3\2\2")
        buf.write(u"\2WV\3\2\2\2X\21\3\2\2\2Y]\7\21\2\2Z\\\5\26\f\2[Z\3\2")
        buf.write(u"\2\2\\_\3\2\2\2][\3\2\2\2]^\3\2\2\2^`\3\2\2\2_]\3\2\2")
        buf.write(u"\2`a\7\22\2\2a\23\3\2\2\2bc\7\23\2\2cd\5(\25\2d\25\3")
        buf.write(u"\2\2\2ef\5\30\r\2fi\5\"\22\2gh\7\27\2\2hj\5$\23\2ig\3")
        buf.write(u"\2\2\2ij\3\2\2\2jk\3\2\2\2kl\7!\2\2l\27\3\2\2\2mp\5\32")
        buf.write(u"\16\2np\5 \21\2om\3\2\2\2on\3\2\2\2p\31\3\2\2\2qr\7\37")
        buf.write(u"\2\2rv\5\34\17\2st\7 \2\2tv\5\36\20\2uq\3\2\2\2us\3\2")
        buf.write(u"\2\2v\33\3\2\2\2wx\7\24\2\2xy\5\30\r\2yz\7\25\2\2z\35")
        buf.write(u"\3\2\2\2{|\7\24\2\2|}\5 \21\2}~\7\26\2\2~\177\5\30\r")
        buf.write(u"\2\177\u0080\7\25\2\2\u0080\37\3\2\2\2\u0081\u008a\7")
        buf.write(u"\30\2\2\u0082\u008a\7\31\2\2\u0083\u008a\7\32\2\2\u0084")
        buf.write(u"\u008a\7\33\2\2\u0085\u008a\7\34\2\2\u0086\u008a\7\35")
        buf.write(u"\2\2\u0087\u008a\7\36\2\2\u0088\u008a\5&\24\2\u0089\u0081")
        buf.write(u"\3\2\2\2\u0089\u0082\3\2\2\2\u0089\u0083\3\2\2\2\u0089")
        buf.write(u"\u0084\3\2\2\2\u0089\u0085\3\2\2\2\u0089\u0086\3\2\2")
        buf.write(u"\2\u0089\u0087\3\2\2\2\u0089\u0088\3\2\2\2\u008a!\3\2")
        buf.write(u"\2\2\u008b\u008c\5(\25\2\u008c#\3\2\2\2\u008d\u008e\5")
        buf.write(u"(\25\2\u008e%\3\2\2\2\u008f\u0090\5(\25\2\u0090\'\3\2")
        buf.write(u"\2\2\u0091\u0092\7%\2\2\u0092)\3\2\2\2\16,.\629;RW]i")
        buf.write(u"ou\u0089")
        return buf.getvalue()


class HTTPIDL ( Parser ):

    grammarFileName = "HTTPIDL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'MESSAGE'", u"'STRUCT'", u"'GET'", 
                     u"'HEAD'", u"'TRACE'", u"'CONNECT'", u"'OPTIONS'", 
                     u"'POST'", u"'PUT'", u"'PATCH'", u"'DELETE'", u"'REQUEST'", 
                     u"'RESPONSE'", u"'/'", u"'{'", u"'}'", u"'$'", u"'<'", 
                     u"'>'", u"','", u"'='", u"'INT32'", u"'INT64'", u"'BOOL'", 
                     u"'DOUBLE'", u"'STRING'", u"'FILE'", u"'BLOB'", u"'ARRAY'", 
                     u"'DICT'", u"';'" ]

    symbolicNames = [ u"<INVALID>", u"MESSAGE", u"STRUCT", u"GET", u"HEAD", 
                      u"TRACE", u"CONNECT", u"OPTIONS", u"POST", u"PUT", 
                      u"PATCH", u"DELETE", u"REQUEST", u"RESPONSE", u"BACKSLASH", 
                      u"LCURLY", u"RCURLY", u"DOLLAR", u"LABRACKET", u"RABRACKET", 
                      u"COMMA", u"ASSIGN", u"INT32", u"INT64", u"BOOL", 
                      u"DOUBLE", u"STRING", u"FILE", u"BLOB", u"ARRAY", 
                      u"DICT", u"SEMICOLON", u"COMMENT", u"NL", u"WS", u"IDENT" ]

    RULE_entry = 0
    RULE_message = 1
    RULE_struct = 2
    RULE_request = 3
    RULE_response = 4
    RULE_method = 5
    RULE_uri = 6
    RULE_uriPathComponent = 7
    RULE_structBody = 8
    RULE_parameterInUri = 9
    RULE_parameterMap = 10
    RULE_paramType = 11
    RULE_genericType = 12
    RULE_arrayGenericParam = 13
    RULE_dictGenericParam = 14
    RULE_baseType = 15
    RULE_key = 16
    RULE_value = 17
    RULE_structName = 18
    RULE_identifier = 19

    ruleNames =  [ u"entry", u"message", u"struct", u"request", u"response", 
                   u"method", u"uri", u"uriPathComponent", u"structBody", 
                   u"parameterInUri", u"parameterMap", u"paramType", u"genericType", 
                   u"arrayGenericParam", u"dictGenericParam", u"baseType", 
                   u"key", u"value", u"structName", u"identifier" ]

    EOF = Token.EOF
    MESSAGE=1
    STRUCT=2
    GET=3
    HEAD=4
    TRACE=5
    CONNECT=6
    OPTIONS=7
    POST=8
    PUT=9
    PATCH=10
    DELETE=11
    REQUEST=12
    RESPONSE=13
    BACKSLASH=14
    LCURLY=15
    RCURLY=16
    DOLLAR=17
    LABRACKET=18
    RABRACKET=19
    COMMA=20
    ASSIGN=21
    INT32=22
    INT64=23
    BOOL=24
    DOUBLE=25
    STRING=26
    FILE=27
    BLOB=28
    ARRAY=29
    DICT=30
    SEMICOLON=31
    COMMENT=32
    NL=33
    WS=34
    IDENT=35

    def __init__(self, input):
        super(HTTPIDL, self).__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class EntryContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.EntryContext, self).__init__(parent, invokingState)
            self.parser = parser

        def message(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.MessageContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.MessageContext,i)


        def struct(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.StructContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.StructContext,i)


        def EOF(self):
            return self.getToken(HTTPIDL.EOF, 0)

        def getRuleIndex(self):
            return HTTPIDL.RULE_entry




    def entry(self):

        localctx = HTTPIDL.EntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_entry)
        self._la = 0 # Token type
        try:
            self.state = 48
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==HTTPIDL.MESSAGE or _la==HTTPIDL.STRUCT:
                    self.state = 42
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [HTTPIDL.MESSAGE]:
                        self.state = 40
                        self.message()
                        pass
                    elif token in [HTTPIDL.STRUCT]:
                        self.state = 41
                        self.struct()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 46
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 47
                self.match(HTTPIDL.EOF)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MessageContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.MessageContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MESSAGE(self):
            return self.getToken(HTTPIDL.MESSAGE, 0)

        def uri(self):
            return self.getTypedRuleContext(HTTPIDL.UriContext,0)


        def LCURLY(self):
            return self.getToken(HTTPIDL.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(HTTPIDL.RCURLY, 0)

        def request(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.RequestContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.RequestContext,i)


        def response(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.ResponseContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.ResponseContext,i)


        def getRuleIndex(self):
            return HTTPIDL.RULE_message




    def message(self):

        localctx = HTTPIDL.MessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_message)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.match(HTTPIDL.MESSAGE)
            self.state = 51
            self.uri()
            self.state = 52
            self.match(HTTPIDL.LCURLY)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HTTPIDL.GET) | (1 << HTTPIDL.HEAD) | (1 << HTTPIDL.TRACE) | (1 << HTTPIDL.CONNECT) | (1 << HTTPIDL.OPTIONS) | (1 << HTTPIDL.POST) | (1 << HTTPIDL.PUT) | (1 << HTTPIDL.PATCH) | (1 << HTTPIDL.DELETE))) != 0):
                self.state = 55
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 53
                    self.request()
                    pass

                elif la_ == 2:
                    self.state = 54
                    self.response()
                    pass


                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 60
            self.match(HTTPIDL.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.StructContext, self).__init__(parent, invokingState)
            self.parser = parser

        def STRUCT(self):
            return self.getToken(HTTPIDL.STRUCT, 0)

        def structName(self):
            return self.getTypedRuleContext(HTTPIDL.StructNameContext,0)


        def structBody(self):
            return self.getTypedRuleContext(HTTPIDL.StructBodyContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_struct




    def struct(self):

        localctx = HTTPIDL.StructContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_struct)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(HTTPIDL.STRUCT)
            self.state = 63
            self.structName()
            self.state = 64
            self.structBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RequestContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.RequestContext, self).__init__(parent, invokingState)
            self.parser = parser

        def method(self):
            return self.getTypedRuleContext(HTTPIDL.MethodContext,0)


        def REQUEST(self):
            return self.getToken(HTTPIDL.REQUEST, 0)

        def structBody(self):
            return self.getTypedRuleContext(HTTPIDL.StructBodyContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_request




    def request(self):

        localctx = HTTPIDL.RequestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_request)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.method()
            self.state = 67
            self.match(HTTPIDL.REQUEST)
            self.state = 68
            self.structBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ResponseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def method(self):
            return self.getTypedRuleContext(HTTPIDL.MethodContext,0)


        def RESPONSE(self):
            return self.getToken(HTTPIDL.RESPONSE, 0)

        def structBody(self):
            return self.getTypedRuleContext(HTTPIDL.StructBodyContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_response




    def response(self):

        localctx = HTTPIDL.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.method()
            self.state = 71
            self.match(HTTPIDL.RESPONSE)
            self.state = 72
            self.structBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.MethodContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(HTTPIDL.GET, 0)

        def POST(self):
            return self.getToken(HTTPIDL.POST, 0)

        def DELETE(self):
            return self.getToken(HTTPIDL.DELETE, 0)

        def PUT(self):
            return self.getToken(HTTPIDL.PUT, 0)

        def PATCH(self):
            return self.getToken(HTTPIDL.PATCH, 0)

        def HEAD(self):
            return self.getToken(HTTPIDL.HEAD, 0)

        def TRACE(self):
            return self.getToken(HTTPIDL.TRACE, 0)

        def CONNECT(self):
            return self.getToken(HTTPIDL.CONNECT, 0)

        def OPTIONS(self):
            return self.getToken(HTTPIDL.OPTIONS, 0)

        def getRuleIndex(self):
            return HTTPIDL.RULE_method




    def method(self):

        localctx = HTTPIDL.MethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_method)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HTTPIDL.GET) | (1 << HTTPIDL.HEAD) | (1 << HTTPIDL.TRACE) | (1 << HTTPIDL.CONNECT) | (1 << HTTPIDL.OPTIONS) | (1 << HTTPIDL.POST) | (1 << HTTPIDL.PUT) | (1 << HTTPIDL.PATCH) | (1 << HTTPIDL.DELETE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UriContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.UriContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BACKSLASH(self, i=None):
            if i is None:
                return self.getTokens(HTTPIDL.BACKSLASH)
            else:
                return self.getToken(HTTPIDL.BACKSLASH, i)

        def uriPathComponent(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.UriPathComponentContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.UriPathComponentContext,i)


        def getRuleIndex(self):
            return HTTPIDL.RULE_uri




    def uri(self):

        localctx = HTTPIDL.UriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_uri)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==HTTPIDL.BACKSLASH:
                self.state = 76
                self.match(HTTPIDL.BACKSLASH)
                self.state = 77
                self.uriPathComponent()
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UriPathComponentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.UriPathComponentContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(HTTPIDL.IdentifierContext,0)


        def parameterInUri(self):
            return self.getTypedRuleContext(HTTPIDL.ParameterInUriContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_uriPathComponent




    def uriPathComponent(self):

        localctx = HTTPIDL.UriPathComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_uriPathComponent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HTTPIDL.IDENT]:
                self.state = 83
                self.identifier()
                pass
            elif token in [HTTPIDL.DOLLAR]:
                self.state = 84
                self.parameterInUri()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructBodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.StructBodyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LCURLY(self):
            return self.getToken(HTTPIDL.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(HTTPIDL.RCURLY, 0)

        def parameterMap(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(HTTPIDL.ParameterMapContext)
            else:
                return self.getTypedRuleContext(HTTPIDL.ParameterMapContext,i)


        def getRuleIndex(self):
            return HTTPIDL.RULE_structBody




    def structBody(self):

        localctx = HTTPIDL.StructBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_structBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.match(HTTPIDL.LCURLY)
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HTTPIDL.INT32) | (1 << HTTPIDL.INT64) | (1 << HTTPIDL.BOOL) | (1 << HTTPIDL.DOUBLE) | (1 << HTTPIDL.STRING) | (1 << HTTPIDL.FILE) | (1 << HTTPIDL.BLOB) | (1 << HTTPIDL.ARRAY) | (1 << HTTPIDL.DICT) | (1 << HTTPIDL.IDENT))) != 0):
                self.state = 88
                self.parameterMap()
                self.state = 93
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 94
            self.match(HTTPIDL.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterInUriContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ParameterInUriContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(HTTPIDL.DOLLAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(HTTPIDL.IdentifierContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_parameterInUri




    def parameterInUri(self):

        localctx = HTTPIDL.ParameterInUriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_parameterInUri)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.match(HTTPIDL.DOLLAR)
            self.state = 97
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterMapContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ParameterMapContext, self).__init__(parent, invokingState)
            self.parser = parser

        def paramType(self):
            return self.getTypedRuleContext(HTTPIDL.ParamTypeContext,0)


        def key(self):
            return self.getTypedRuleContext(HTTPIDL.KeyContext,0)


        def SEMICOLON(self):
            return self.getToken(HTTPIDL.SEMICOLON, 0)

        def ASSIGN(self):
            return self.getToken(HTTPIDL.ASSIGN, 0)

        def value(self):
            return self.getTypedRuleContext(HTTPIDL.ValueContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_parameterMap




    def parameterMap(self):

        localctx = HTTPIDL.ParameterMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_parameterMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.paramType()
            self.state = 100
            self.key()
            self.state = 103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==HTTPIDL.ASSIGN:
                self.state = 101
                self.match(HTTPIDL.ASSIGN)
                self.state = 102
                self.value()


            self.state = 105
            self.match(HTTPIDL.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParamTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ParamTypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def genericType(self):
            return self.getTypedRuleContext(HTTPIDL.GenericTypeContext,0)


        def baseType(self):
            return self.getTypedRuleContext(HTTPIDL.BaseTypeContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_paramType




    def paramType(self):

        localctx = HTTPIDL.ParamTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_paramType)
        try:
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HTTPIDL.ARRAY, HTTPIDL.DICT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 107
                self.genericType()
                pass
            elif token in [HTTPIDL.INT32, HTTPIDL.INT64, HTTPIDL.BOOL, HTTPIDL.DOUBLE, HTTPIDL.STRING, HTTPIDL.FILE, HTTPIDL.BLOB, HTTPIDL.IDENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 108
                self.baseType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GenericTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.GenericTypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(HTTPIDL.ARRAY, 0)

        def arrayGenericParam(self):
            return self.getTypedRuleContext(HTTPIDL.ArrayGenericParamContext,0)


        def DICT(self):
            return self.getToken(HTTPIDL.DICT, 0)

        def dictGenericParam(self):
            return self.getTypedRuleContext(HTTPIDL.DictGenericParamContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_genericType




    def genericType(self):

        localctx = HTTPIDL.GenericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_genericType)
        try:
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HTTPIDL.ARRAY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 111
                self.match(HTTPIDL.ARRAY)
                self.state = 112
                self.arrayGenericParam()
                pass
            elif token in [HTTPIDL.DICT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(HTTPIDL.DICT)
                self.state = 114
                self.dictGenericParam()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayGenericParamContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ArrayGenericParamContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LABRACKET(self):
            return self.getToken(HTTPIDL.LABRACKET, 0)

        def paramType(self):
            return self.getTypedRuleContext(HTTPIDL.ParamTypeContext,0)


        def RABRACKET(self):
            return self.getToken(HTTPIDL.RABRACKET, 0)

        def getRuleIndex(self):
            return HTTPIDL.RULE_arrayGenericParam




    def arrayGenericParam(self):

        localctx = HTTPIDL.ArrayGenericParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arrayGenericParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(HTTPIDL.LABRACKET)
            self.state = 118
            self.paramType()
            self.state = 119
            self.match(HTTPIDL.RABRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DictGenericParamContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.DictGenericParamContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LABRACKET(self):
            return self.getToken(HTTPIDL.LABRACKET, 0)

        def baseType(self):
            return self.getTypedRuleContext(HTTPIDL.BaseTypeContext,0)


        def COMMA(self):
            return self.getToken(HTTPIDL.COMMA, 0)

        def paramType(self):
            return self.getTypedRuleContext(HTTPIDL.ParamTypeContext,0)


        def RABRACKET(self):
            return self.getToken(HTTPIDL.RABRACKET, 0)

        def getRuleIndex(self):
            return HTTPIDL.RULE_dictGenericParam




    def dictGenericParam(self):

        localctx = HTTPIDL.DictGenericParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_dictGenericParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(HTTPIDL.LABRACKET)
            self.state = 122
            self.baseType()
            self.state = 123
            self.match(HTTPIDL.COMMA)
            self.state = 124
            self.paramType()
            self.state = 125
            self.match(HTTPIDL.RABRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BaseTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.BaseTypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INT32(self):
            return self.getToken(HTTPIDL.INT32, 0)

        def INT64(self):
            return self.getToken(HTTPIDL.INT64, 0)

        def BOOL(self):
            return self.getToken(HTTPIDL.BOOL, 0)

        def DOUBLE(self):
            return self.getToken(HTTPIDL.DOUBLE, 0)

        def STRING(self):
            return self.getToken(HTTPIDL.STRING, 0)

        def FILE(self):
            return self.getToken(HTTPIDL.FILE, 0)

        def BLOB(self):
            return self.getToken(HTTPIDL.BLOB, 0)

        def structName(self):
            return self.getTypedRuleContext(HTTPIDL.StructNameContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_baseType




    def baseType(self):

        localctx = HTTPIDL.BaseTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_baseType)
        try:
            self.state = 135
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HTTPIDL.INT32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 127
                self.match(HTTPIDL.INT32)
                pass
            elif token in [HTTPIDL.INT64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                self.match(HTTPIDL.INT64)
                pass
            elif token in [HTTPIDL.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 129
                self.match(HTTPIDL.BOOL)
                pass
            elif token in [HTTPIDL.DOUBLE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 130
                self.match(HTTPIDL.DOUBLE)
                pass
            elif token in [HTTPIDL.STRING]:
                self.enterOuterAlt(localctx, 5)
                self.state = 131
                self.match(HTTPIDL.STRING)
                pass
            elif token in [HTTPIDL.FILE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 132
                self.match(HTTPIDL.FILE)
                pass
            elif token in [HTTPIDL.BLOB]:
                self.enterOuterAlt(localctx, 7)
                self.state = 133
                self.match(HTTPIDL.BLOB)
                pass
            elif token in [HTTPIDL.IDENT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 134
                self.structName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.KeyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(HTTPIDL.IdentifierContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_key




    def key(self):

        localctx = HTTPIDL.KeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_key)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.ValueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(HTTPIDL.IdentifierContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_value




    def value(self):

        localctx = HTTPIDL.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructNameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.StructNameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(HTTPIDL.IdentifierContext,0)


        def getRuleIndex(self):
            return HTTPIDL.RULE_structName




    def structName(self):

        localctx = HTTPIDL.StructNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_structName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(HTTPIDL.IdentifierContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(HTTPIDL.IDENT, 0)

        def getRuleIndex(self):
            return HTTPIDL.RULE_identifier




    def identifier(self):

        localctx = HTTPIDL.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(HTTPIDL.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





